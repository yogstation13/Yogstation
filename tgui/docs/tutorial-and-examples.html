<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <base href="../../" />
    <link rel="stylesheet" href="dmdoc.css" />
    <title>tgui&#x2F;docs&#x2F;tutorial-and-examples.md - Yogstation 13</title>
</head>
<body>
<header>
    <a href="index.html">Yogstation 13</a> -
    <a href="index.html#modules">Modules</a> -
    <a href="index.html#types">Types</a>
</header>
<main>
<h1>Tutorial and Examples <aside>tgui/docs/tutorial-and-examples.md</aside> 
            <a href="https://github.com/yogstation13/Yogstation/blob/4a2e65ae8ad6e6db2dbf19041a5b8e178d76cefa/tgui/docs/tutorial-and-examples.md">
        <img src="git.png" width="16" height="16" title="tgui&#x2F;docs&#x2F;tutorial-and-examples.md"/></a></h1>

<table class="summary" cellspacing="0">
        <tr><td colspan="2"><hh2 id="main-concepts">Main concepts</hh2>
<p>Basic tgui backend code consists of the following vars and procs:</p>
<pre><code>ui_interact(mob/user, datum/tgui/ui)
ui_data(mob/user)
ui_act(action, params)
ui_state()
</code></pre>
<ul>
<li><code>src_object</code> - The atom, which UI corresponds to in the game world.</li>
<li><code>ui_interact</code> - The proc where you will handle a request to open an
interface. Typically, you would update an existing UI (if it exists),
or set up a new instance of UI by calling the <code>SStgui</code> subsystem.</li>
<li><code>ui_data</code> - In this proc you munges whatever complex data your <code>src_object</code>
has into an associative list, which will then be sent to UI as a JSON string.</li>
<li><code>ui_act</code> - This proc receives user actions and reacts to them by changing
the state of the game.</li>
<li><code>ui_state</code> - This proc dictates under what conditions a UI may be interacted
with. This may be the standard checks that check if you are in range and
conscious, or more.</li>
</ul>
<p>Once backend is complete, you create an new interface component on the
frontend, which will receive this JSON data and render it on screen.</p>
<p>States are easy to write and extend, and what make tgui interactions so
powerful. Because states can be overridden from other procs, you can build
powerful interactions for embedded objects or remote access.</p>
<hh2 id="using-it">Using It</hh2><hh3 id="backend">Backend</hh3>
<p>Let's start with a very basic hello world.</p>
<pre><code class="language-dm">/obj/machinery/my_machine/ui_interact(mob/user, datum/tgui/ui)
  ui = SStgui.try_update_ui(user, src, ui)
  if(!ui)
    ui = new(user, src, &quot;MyMachine&quot;)
    ui.open()
</code></pre>
<p>This is the proc that defines our interface. There's a bit going on here, so
let's break it down. First, we override the ui_interact proc on our object. This
will be called by <code>interact</code> for you, which is in turn called by <code>attack_hand</code>
(or <code>attack_self</code> for items). <code>ui_interact</code> is also called to update a UI (hence
the <code>try_update_ui</code>), so we accept an existing UI to update.</p>
<p>Inside the <code>if(!ui)</code> block (which means we are creating a new UI), we choose our
template, title, and size; we can also set various options like <code>style</code> (for
themes), or autoupdate. These options will be elaborated on later (as will
<code>ui_state</code>s).</p>
<p>After <code>ui_interact</code>, we need to define <code>ui_data</code>. This just returns a list of
data for our object to use. Let's imagine our object has a few vars:</p>
<pre><code class="language-dm">/obj/machinery/my_machine/ui_data(mob/user)
  var/list/data = list()
  data[&quot;health&quot;] = health
  data[&quot;color&quot;] = color

  return data
</code></pre>
<p>The <code>ui_data</code> proc is what people often find the hardest about tgui, but its
really quite simple! You just need to represent your object as numbers, strings,
and lists, instead of atoms and datums.</p>
<p>Finally, the <code>ui_act</code> proc is called by the interface whenever the user used an
input. The input's <code>action</code> and <code>params</code> are passed to the proc.</p>
<pre><code class="language-dm">/obj/machinery/my_machine/ui_act(action, params)
  if(..())
    return
  if(action == &quot;change_color&quot;)
    var/new_color = params[&quot;color&quot;]
    if(!(color in allowed_coors))
      return FALSE
    color = new_color
    . = TRUE
  update_appearance(UPDATE_ICON)
</code></pre>
<p>The <code>..()</code> (parent call) is very important here, as it is how we check that the
user is allowed to use this interface (to avoid so-called href exploits). It is
also very important to clamp and sanitize all input here. Always assume the user
is attempting to exploit the game.</p>
<p>Also note the use of <code>. = TRUE</code> (or <code>FALSE</code>), which is used to notify the UI
that this input caused an update. This is especially important for UIs that do
not auto-update, as otherwise the user will never see their change.</p>
<hh3 id="frontend">Frontend</hh3>
<p>Finally, let's make a React Component for your interface. This is also
a source of confusion for new developers. If you got some basic javascript
and HTML knowledge, that should ease the learning process, although we
recommend getting yourself introduced to
<a href="https://reactjs.org/docs/introducing-jsx.html">React and JSX</a>.</p>
<p>A React component is not a regular HTML template. A component is a
javascript function, which accepts a <code>props</code> object (that contains
properties passed to a component) and a <code>context</code> object (which is
necessary to access UI data) as arguments, and outputs an HTML-like
structure.</p>
<p>So let's create our first React Component. Create a file with a name
<code>SampleInterface.js</code> (or any other name you want), and copy this code
snippet (make sure component name matches the file name):</p>
<pre><code class="language-jsx">import { useBackend } from '../backend';
import { Button, LabeledList, Section } from '../components';
import { Window } from '../layouts';

export const SampleInterface = (props, context) =&gt; {
  const { act, data } = useBackend(context);
  // Extract `health` and `color` variables from the `data` object.
  const {
    health,
    color,
  } = data;
  return (
    &lt;Window&gt;
      &lt;Window.Content scrollable&gt;
        &lt;Section title=&quot;Health status&quot;&gt;
          &lt;LabeledList&gt;
            &lt;LabeledList.Item label=&quot;Health&quot;&gt;
              {health}
            &lt;/LabeledList.Item&gt;
            &lt;LabeledList.Item label=&quot;Color&quot;&gt;
              {color}
            &lt;/LabeledList.Item&gt;
            &lt;LabeledList.Item label=&quot;Button&quot;&gt;
              &lt;Button
                content=&quot;Dispatch a 'test' action&quot;
                onClick={() =&gt; act('test')} /&gt;
            &lt;/LabeledList.Item&gt;
          &lt;/LabeledList&gt;
        &lt;/Section&gt;
      &lt;/Window.Content&gt;
    &lt;/Window&gt;
  );
};
</code></pre>
<p>Here are the key variables you get from a <code>useBackend(context)</code> function:</p>
<ul>
<li><code>config</code> is part of core tgui. It contains meta-information about the
interface and who uses it, BYOND refs to various objects, and so forth.
You are rarely going to use it, but sometimes it can be used to your
advantage when doing complex UIs.</li>
<li><code>data</code> is the data returned from <code>ui_data</code> and <code>ui_static_data</code> procs in
your DM code. Pretty straight forward.
<ul>
<li>Note, that javascript doesn't have associative arrays, so when you
return an associative list from DM, it will be available in <code>data</code> as a
javascript object instead of an array. You can use it normally
like so: <code>object.key</code>, so it's not a problem if it's representing a
data structure, but common <code>Array</code> methods, such as <code>array.map(item =&gt; ...)</code>,
are not available on it. Always prefer returning clean arrays from your
code, since arrays are easier to work with in javascript!</li>
</ul>
</li>
<li><code>act(name, params)</code> is a function, which you can call to dispatch an action
to your DM code. It will be processed in <code>ui_act</code> proc. Action name will be
available in <code>params[&quot;action&quot;]</code>, mixed together with the rest of parameters
you have passed in <code>params</code> object.</li>
</ul>
<p><strong>Let's talk about the syntax.</strong></p>
<p>The syntax you're seeing here is called JSX - a very simple extension of the
core javascript language. It's basically a pre-processor, that takes
expressions that look like html, and turns them into function calls.</p>
<p>Take a look at this example:</p>
<pre><code class="language-jsx">&lt;div className={'color-' + status}&gt;
  You are in {status} condition!
&lt;/div&gt;
</code></pre>
<p>After compiling the code above, this is what it becomes:</p>
<pre><code class="language-js">createElement('div',
  { className: 'color-' + status },
  'You are in ', status, ' condition!');
</code></pre>
<p>It is very important to remember, that JSX is just a javascript expression
made out of <code>createElement</code> function calls. Naturally, this allows doing
all sorts of stuff on these expressions, just like you would with anything
else in javascript.</p>
<p>Take a look at these examples:</p>
<p><strong>Render an element inside of another element if <code>showProgress</code> is true.</strong></p>
<p>This example uses the <code>&amp;&amp;</code> operator (the logical AND). It returns
the first operand if it evaluates to <code>false</code>, and returns the second operand
if it evaluates to <code>true</code>.</p>
<p>If <code>showProgress</code> is <code>true</code>, the whole expression evaluates
to a <code>&lt;ProgressBar /&gt;</code> element. If <code>showProgress</code> is <code>false</code>, the whole
expression evaluates to <code>false</code>, and <code>false</code> is not rendered by React.</p>
<pre><code class="language-jsx">&lt;Box&gt;
  {showProgress &amp;&amp; (
    &lt;ProgressBar value={progress} /&gt;
  )}
&lt;/Box&gt;
</code></pre>
<p>You can also use the <code>||</code> operator (the logical OR), which works the same way,
except it will return the second operand on <code>false</code> instead of <code>true</code>.</p>
<p><strong>Loop over the array to map every item to a corresponding React element.</strong></p>
<p><code>Array.map()</code> is a method, that calls a function on every item in the array,
and builds a new array based on what was returned by that function.</p>
<pre><code class="language-jsx">&lt;LabeledList&gt;
  {items.map(item =&gt; (
    &lt;LabeledList.Item
      key={item.id}
      label={item.label}&gt;
      {item.content}
    &lt;/LabeledList.Item&gt;
  ))}
&lt;/LabeledList&gt;
</code></pre>
<p>If you need more examples of what you can do with React, see the
<a href="docs/converting-old-tgui-interfaces.md">interface conversion guide</a>.</p>
<hh4 id="splitting-uis-into-smaller-modular-components">Splitting UIs into smaller, modular components</hh4>
<p>You interface will eventually get really, really big. The easiest thing
you can do in this situation, is divide and conquer. Grab a chunk of your
JSX code, and wrap it into a second, smaller React component:</p>
<pre><code class="language-jsx">import { useBackend } from '../backend';
import { Button, LabeledList, Section } from '../components';
import { Window } from '../layouts';

export const SampleInterface = (props, context) =&gt; {
  return (
    &lt;Window&gt;
      &lt;Window.Content scrollable&gt;
        &lt;HealthStatus user=&quot;Jerry&quot; /&gt;
      &lt;/Window.Content&gt;
    &lt;/Window&gt;
  );
};

const HealthStatus = (props, context) =&gt; {
  const { act, data } = useBackend(context);
  const {
    user,
  } = props;
  const {
    health,
    color,
  } = data;
  return (
    &lt;Section title={&quot;Health status of: &quot; + user}&gt;
      &lt;LabeledList&gt;
        &lt;LabeledList.Item label=&quot;Health&quot;&gt;
          {health}
        &lt;/LabeledList.Item&gt;
        &lt;LabeledList.Item label=&quot;Color&quot;&gt;
          {color}
        &lt;/LabeledList.Item&gt;
      &lt;/LabeledList&gt;
    &lt;/Section&gt;
  );
};
</code></pre>
<hh2 id="copypasta">Copypasta</hh2>
<p>We all do it, even the best of us. If you just want to make a tgui <strong>fast</strong>,
here's what you need (note that you'll probably be forced to clean your shit up
upon code review):</p>
<pre><code class="language-dm">/obj/copypasta/ui_interact(mob/user, datum/tgui/ui)
  ui = SStgui.try_update_ui(user, src, ui)
  if(!ui)
    ui = new(user, src, &quot;copypasta&quot;)
    ui.open()

/obj/copypasta/ui_data(mob/user)
  var/list/data = list()
  data[&quot;var&quot;] = var
  return data

/obj/copypasta/ui_act(action, params)
  if(..())
    return
  switch(action)
    if(&quot;copypasta&quot;)
      var/newvar = params[&quot;var&quot;]
      // A demo of proper input sanitation.
      var = CLAMP(newvar, min_val, max_val)
      . = TRUE
  update_appearance(UPDATE_ICON) // Not applicable to all objects.
</code></pre>
<p>And the template:</p>
<pre><code class="language-jsx">import { useBackend } from '../backend';
import { Button, LabeledList, Section } from '../components';
import { Window } from '../layouts';

export const SampleInterface = (props, context) =&gt; {
  const { act, data } = useBackend(context);
  // Extract `health` and `color` variables from the `data` object.
  const {
    health,
    color,
  } = data;
  return (
    &lt;Window&gt;
      &lt;Window.Content scrollable&gt;
        &lt;Section title=&quot;Health status&quot;&gt;
          &lt;LabeledList&gt;
            &lt;LabeledList.Item label=&quot;Health&quot;&gt;
              {health}
            &lt;/LabeledList.Item&gt;
            &lt;LabeledList.Item label=&quot;Color&quot;&gt;
              {color}
            &lt;/LabeledList.Item&gt;
            &lt;LabeledList.Item label=&quot;Button&quot;&gt;
              &lt;Button
                content=&quot;Dispatch a 'test' action&quot;
                onClick={() =&gt; act('test')} /&gt;
            &lt;/LabeledList.Item&gt;
          &lt;/LabeledList&gt;
        &lt;/Section&gt;
      &lt;/Window.Content&gt;
    &lt;/Window&gt;
  );
};
</code></pre></td></tr></table></main>
<footer>
    yogstation.dme
    <a href="https://github.com/yogstation13/Yogstation/tree/4a2e65ae8ad6e6db2dbf19041a5b8e178d76cefa">4a2e65a</a>
        (master) &mdash; <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.8.0</a></footer>
</body>
</html>
